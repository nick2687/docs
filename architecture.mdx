---
title: Architecture
description: Understand the technical architecture and design decisions behind HomeLens Web
---

# Architecture

This document outlines the technical architecture, design patterns, and key decisions behind HomeLens Web.

## Technology Stack

### Frontend

- **Framework**: Next.js 14+ with App Router
- **Language**: TypeScript for type safety
- **UI Framework**: React 18+
- **Styling**: Tailwind CSS + shadcn/ui components
- **State Management**: React Context API + SWR for data fetching
- **Forms**: React Hook Form + Zod validation

### Backend

- **Runtime**: Node.js (via Next.js API Routes)
- **Database**: Firebase Firestore
- **Authentication**: Firebase Authentication
- **Storage**: Firebase Storage
- **File Processing**: jsPDF for PDF generation

### Deployment

- **Hosting**: Vercel (recommended) or any Node.js hosting
- **CDN**: Vercel Edge Network
- **Database**: Firebase Firestore (Google Cloud)

## Application Structure

### Directory Organization

```
web/
├── app/                      # Next.js App Router
│   ├── (auth)/              # Authentication routes (login, signup)
│   ├── dashboard/           # Protected dashboard routes
│   ├── portal/              # Public client portal
│   ├── widget/              # Embeddable widgets
│   ├── api/                 # API routes
│   └── layout.tsx           # Root layout
├── components/              # React components
│   ├── ui/                  # shadcn/ui base components
│   ├── dashboard/           # Dashboard-specific components
│   ├── templates/           # Template management
│   ├── services/            # Service management
│   ├── contacts/            # Contact management
│   └── inspections/         # Inspection components
├── lib/                     # Core utilities
│   ├── firebase/            # Firebase client & admin
│   ├── hooks/               # Custom React hooks
│   ├── contexts/            # React Context providers
│   ├── utils/               # Utility functions
│   └── integrations/        # Third-party integrations
├── types/                   # TypeScript definitions
└── public/                  # Static assets
```

## Design Patterns

### Data Fetching

We use **SWR** (stale-while-revalidate) for data fetching with React Server Components:

```typescript
import useSWR from 'swr'

function useTemplates() {
  const { data, error, mutate } = useSWR('/api/templates', fetcher)
  return { templates: data, isLoading: !error && !data, error, mutate }
}
```

### State Management

- **Local State**: React `useState` for component-specific state
- **Shared State**: React Context API for global state (auth, theme)
- **Server State**: SWR for server data with caching

### Authentication

Firebase Authentication with custom middleware:

```typescript
// middleware.ts
export function middleware(request: NextRequest) {
  const session = await getSession(request)
  if (!session && request.nextUrl.pathname.startsWith('/dashboard')) {
    return NextResponse.redirect(new URL('/login', request.url))
  }
}
```

### Database Schema

Firestore collections follow a flat structure for optimal query performance:

- `users` - User profiles and settings
- `templates` - Inspection templates
- `templateSections` - Template sections
- `templateItems` - Template items
- `commentTemplates` - Pre-defined comments
- `services` - Inspection services
- `fees` - Service fees
- `feeOptions` - Fee tier options
- `contacts` - CRM contacts
- `inspections` - Inspection records

See [Firestore Structure](/docs/firestore-structure) for detailed schema.

## Key Architectural Decisions

### 1. Flat Collections

We avoid deeply nested subcollections for better query performance and simpler security rules.

### 2. Denormalization

Commonly accessed data is stored together to reduce reads. For example, `inspections` include `serviceName` even though `serviceId` exists.

### 3. User Isolation

All documents contain `userId` for security rules and efficient querying.

### 4. Soft Deletes

Use status flags (`isActive`, `isDeleted`) instead of hard deletes for data recovery.

### 5. Real-time Sync

Firestore provides real-time updates across web and mobile apps without custom sync logic.

## Security

### Authentication

- Firebase Authentication handles all user authentication
- JWT tokens managed by Firebase
- Protected routes via middleware

### Authorization

- Firestore Security Rules enforce user isolation
- API routes verify authentication server-side
- User can only access their own data

### Data Validation

- Client-side: Zod schemas with React Hook Form
- Server-side: Re-validation in API routes
- Database: Firestore rules as final layer

## Performance Optimizations

### Code Splitting

Next.js automatically code-splits by route and component.

### Image Optimization

Next.js Image component with Firebase Storage URLs:

```typescript
<Image
  src={logoUrl}
  alt="Logo"
  width={200}
  height={200}
  loader={firebaseImageLoader}
/>
```

### Caching Strategy

- SWR caching for API responses
- Next.js static generation for public pages
- Firebase Firestore offline persistence (mobile)

## Error Handling

### Client-Side

```typescript
try {
  await createTemplate(data)
} catch (error) {
  toast.error('Failed to create template')
  console.error(error)
}
```

### Server-Side

```typescript
export async function POST(request: Request) {
  try {
    // ... logic
    return Response.json({ success: true })
  } catch (error) {
    return Response.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}
```

## Testing Strategy

- **Unit Tests**: Vitest for utility functions
- **Integration Tests**: Vitest for API routes
- **E2E Tests**: Playwright for user flows
- **Type Checking**: TypeScript compiler

## Future Considerations

### Scalability

- Firestore auto-scales with usage
- Consider Cloudflare R2 for storage at scale
- API routes can be migrated to Cloud Functions if needed

### Mobile Sync

Mobile apps will sync to the same Firestore collections, ensuring real-time updates across platforms.

### Multi-tenancy

Current architecture supports multi-tenancy through `userId` isolation. Future enterprise features may require additional isolation layers.

## Related Documentation

- [Getting Started](/docs/getting-started) - Setup instructions
- [Firestore Structure](/docs/firestore-structure) - Database schema
- [API Reference](/docs/api-reference) - API endpoints
- [Development Guide](/docs/development) - Contributing guidelines

